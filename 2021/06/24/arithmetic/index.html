

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>算法题解析 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/images/bg/bgpicture.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法题解析">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-06-24 14:54" pubdate>
        2021-06-24 2:54
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      54
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法题解析</h1>
            
            <div class="markdown-body">
              <h1 id="经典算法题解析"><a href="#经典算法题解析" class="headerlink" title="经典算法题解析"></a>经典算法题解析</h1><h2 id="1、反转链表"><a href="#1、反转链表" class="headerlink" title="1、反转链表"></a>1、反转链表</h2><p>题目：输入一个链表，反转链表后，输出新链表的表头。</p>
<p>例如：输入{1,2,3}，返回值{3,2,1}</p>
<blockquote>
<p>解析</p>
</blockquote>
<p>pre指针：用来记录当前节点的前一个节点</p>
<p>cur指针：用来指向当前节点</p>
<p>由于链表只有单向的指向，当我们想要改变当前节点的指向时，为了防止链表断开，我们需要temp指针保存当前节点的后一个节点。</p>
<p><img src="/2021/06/24/arithmetic/image-20210615194840385.png" srcset="/img/loading.gif" lazyload alt="image-20210615194840385"></p>
<p>初始pre为空，cur指向1，断开前为了防止找不到下一个节点，就提前将下一个节点2放入temp中，然后pre节点和cur节点向后移动，如此往复下去。</p>
<p><img src="/2021/06/24/arithmetic/image-20210615195124122.png" srcset="/img/loading.gif" lazyload alt="image-20210615195124122"></p>
<p>cur指向空时，只需返回新链表的头结点（pre现在指向的）即可。</p>
<p>对于不懂链表的：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lilong117194/article/details/83759106">Java链表的基本使用_lilong117194的博客-CSDN博客_java 链表使用</a></p>
<blockquote>
<p>代码实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> javaBasicsDemo01;<br><br><span class="hljs-comment">//反转链表</span><br><span class="hljs-comment">//输入一个链表，反转链表后，输出新链表的表头。</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReverseListDemo</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		ListNode head=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);<br>		ListNode node1=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">2</span>);<br>		ListNode node2=<span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">3</span>);<br>		head.setNext(node1);<br>		node1.setNext(node2);<br>		ListNode h=head;<br>		<span class="hljs-keyword">while</span>( h !=  <span class="hljs-keyword">null</span>)&#123;<br>			System.out.print(h.getData()+<span class="hljs-string">&quot; &quot;</span>) ;<br>			<span class="hljs-comment">//将下一个节点设置为当前节点s</span><br>			h = h.getNext() ;<br>		&#125;<br>		System.out.println();<br>		head = ReverseList(head);<br>		<span class="hljs-keyword">while</span>( <span class="hljs-keyword">null</span> !=  head)&#123;<br>			System.out.print(head.getData()+<span class="hljs-string">&quot; &quot;</span>) ;<br>			<span class="hljs-comment">//将下一个节点设置为当前节点s</span><br>			head = head.getNext() ;<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">//反转方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode pHead)</span> </span>&#123;<br>		ListNode pre=<span class="hljs-keyword">null</span>;<br>		ListNode cur=pHead;<br>		ListNode temp=<span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">while</span>(cur !=<span class="hljs-keyword">null</span>) &#123;<br>			temp=cur.next;<br>			cur.next=pre;<br>			pre=cur;<br>			cur=temp;<br>		&#125;<br>		<span class="hljs-keyword">return</span> pre;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//链表类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span> </span>&#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> data;<br>	<span class="hljs-keyword">public</span> ListNode next;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">()</span> </span>&#123;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.data = data;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> data;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.data = data;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> next;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(ListNode next)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.next = next;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2021/06/24/arithmetic/image-20210615202401186.png" srcset="/img/loading.gif" lazyload alt="image-20210615202401186"></p>
<p>更多方法：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904022344744967">链表反转(Java三种实现方式) (juejin.cn)</a></p>
<h2 id="2、排序"><a href="#2、排序" class="headerlink" title="2、排序"></a>2、排序</h2><p>题目：给定一个数组，请你编写一个函数，返回该数组排序后的形式。（ 时间限制：1秒    空间限制：256M）</p>
<p>例如：输入[5,2,3,1,4]，返回值[1,2,3,4,5]</p>
<h2 id="3、设计LRU缓存结构"><a href="#3、设计LRU缓存结构" class="headerlink" title="3、设计LRU缓存结构"></a>3、设计LRU缓存结构</h2><h2 id="4、判断链表中是否有环"><a href="#4、判断链表中是否有环" class="headerlink" title="4、判断链表中是否有环"></a>4、判断链表中是否有环</h2><p>题目：判断给定的链表中是否有环。如果有环则返回true，否则返回false。</p>
<p>环形链表的实现：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46726346/article/details/108742370">JAVA实现环形链表（详解）_爱前端的小菜的博客-CSDN博客_java环形链表</a></p>
<blockquote>
<p>快慢指针解决</p>
</blockquote>
<p>判断链表是否有环应该是老生常谈的一个话题了，最简单的一种方式就是快慢指针，<strong>慢指针针每次走一步，快指针每次走两步</strong>，如果相遇就说明有环，如果有一个为空说明没有环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == nullhead.next==<span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">//快慢两个指针</span><br>    ListNode slow = head;<br>    ListNode fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//慢指针每次走一步</span><br>        slow = slow.next;<br>        <span class="hljs-comment">//快指针每次走两步</span><br>        fast = fast.next.next;<br>        <span class="hljs-comment">//如果相遇，说明有环，直接返回true</span><br>        <span class="hljs-keyword">if</span> (slow == fast)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    	&#125;<br>    <span class="hljs-comment">//否则就是没环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>快指针每次走两步，慢指针每次走一步，所以每走一次快慢指针的间距就要缩小一步，在图一中当走n次的时候就会相遇，在图二中当走m-n次的时候就会相遇。</p>
<blockquote>
<p>存放到集合中</p>
</blockquote>
<p>这题还可以把节点存放到集合set中，每次存放的时候判断当前节点是否存在，如果存在，说明有环，直接返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        Set&lt;ListNode&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">//如果重复出现说明有环</span><br>            <span class="hljs-keyword">if</span> (set.contains(head))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-comment">//否则就把当前节点加入到集合中</span><br>            set.add(head);<br>            head = head.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>逐个删除</p>
</blockquote>
<p>一个链表从头节点开始一个个删除，<strong>所谓删除就是让他的next指针指向他自己</strong>。如果没有环，从头结点一个个删除，最后肯定会删完，如下图所示</p>
<p><img src="/2021/06/24/arithmetic/4.1.png" srcset="/img/loading.gif" lazyload alt="图片说明"></p>
<p>如果是环形的，那么有两种情况，一种是o型的，一种是6型的。原理都是一样，我们就看一下o型的</p>
<p><img src="/2021/06/24/arithmetic/4.2.png" srcset="/img/loading.gif" lazyload alt="图片说明"></p>
<p>如上图所示，如果删到最后，肯定会出现<strong>head=head.next</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-comment">//如果head为空，或者他的next指向为空，直接返回false</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//如果出现head.next = head表示有环</span><br>        <span class="hljs-keyword">if</span> (head.next == head)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        ListNode nextNode = head.next;<br>        <span class="hljs-comment">//当前节点的next指向他自己，相当于把它删除了</span><br>        head.next = head;<br>        <span class="hljs-comment">//然后递归，查看下一个节点</span><br>        <span class="hljs-keyword">return</span> hasCycle(nextNode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5、用两个栈实现队列"><a href="#5、用两个栈实现队列" class="headerlink" title="5、用两个栈实现队列"></a>5、用两个栈实现队列</h2><p>题目：用两个栈来实现一个队列，分别完成在队列尾部插入整数(push)和在队列头部删除整数(pop)的功能。 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。</p>
<p>示例:</p>
<p>输入:[“PSH1”,”PSH2”,”POP”,”POP”]        返回:1,2</p>
<p>解析:</p>
<p>“PSH1”:代表将1插入队列尾部</p>
<p>“PSH2”:代表将2插入队列尾部</p>
<p>“POP“:代表删除一个元素，先进先出=&gt;返回1</p>
<p>“POP“:代表删除一个元素，先进先出=&gt;返回2</p>
<blockquote>
<p>方法：模拟</p>
</blockquote>
<p>比如有如下操作：(pop操作确保栈中有元素）</p>
<p><img src="/2021/06/24/arithmetic/5.1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>根据队列的特性，只能pop(1),pop(2),pop之后的结果</p>
<p><img src="/2021/06/24/arithmetic/5.2.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>上述是队列的操作。<br>当push的时候，我们必须要用一个stack来存，假设用stack1来存。</p>
<p><img src="/2021/06/24/arithmetic/5.3.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>那么push操作解决了。那么pop操作怎么办呢？<br>如果pop(1)，但是此时在stack1的栈底，如果要pop，必须再将stack1中的数据push到stack2中，然后在pop，如图</p>
<p><img src="/2021/06/24/arithmetic/5.4.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这样直接弹出stack2的栈顶就可以了。<br>如果要继续pop，那就继续弹出stack2就可以了</p>
<hr>
<p>但是现在总感觉哪里还是有点问题。如果是这样就继续测试几个例子。<br>如果push(5)，</p>
<p><img src="/2021/06/24/arithmetic/5.5.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p><strong>所以最后总结一下：push操作就直接往stack1中push， pop操作需要分类一下：如果stack2为空，那么需要将stack1中的数据转移到stack2中，然后在对stack2进行pop，如果stack2不为空，直接pop就ok。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Stack;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    Stack&lt;Integer&gt; stack1 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    Stack&lt;Integer&gt; stack2 = <span class="hljs-keyword">new</span> Stack&lt;Integer&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> node)</span> </span>&#123;<br>        stack1.push(node);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(stack2.empty())&#123;<br>        <span class="hljs-keyword">while</span>(!stack1.empty())&#123;<br>            stack2.push(stack1.peek());<br>            stack1.pop();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> ret=stack2.peek();<br>        stack2.pop();<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Statck的方法总结（Java）</p>
</blockquote>
<ol>
<li>java中Stack只有一个无参构造函数。</li>
<li>属于stack自己的方法包括<ol>
<li>push( num) //入栈</li>
<li>pop() //栈顶元素出栈</li>
<li>empty() //判定栈是否为空</li>
<li>peek() //获取栈顶元素</li>
<li>search(num) //判端元素num是否在栈中，如果在返回1，不在返回-1。</li>
</ol>
</li>
<li>注意pop()和peek()的区别。pop()会弹出栈顶元素并返回栈顶的值，peek()只是获取栈顶的值，但是并不会把元素从栈顶弹出来。</li>
</ol>
<h2 id="6、跳台阶"><a href="#6、跳台阶" class="headerlink" title="6、跳台阶"></a>6、跳台阶</h2><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<blockquote>
<p>方法一：递归</p>
</blockquote>
<p>题目分析，假设f[i]表示在第i个台阶上可能的方法数。逆向思维。如果我从第n个台阶进行下台阶，下一步有2中可能，一种走到第n-1个台阶，一种是走到第n-2个台阶。所以f[n] = f[n-1] + f[n-2].<br>那么初始条件了，f[0] = f[1] = 1。<br>所以就变成了：f[n] = f[n-1] + f[n-2], 初始值f[0]=1, f[1]=1，目标求f[n]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//递归方式（斐波那契）</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>       <span class="hljs-keyword">if</span>(target==<span class="hljs-number">1</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target==<span class="hljs-number">2</span>)<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">else</span><br>           <span class="hljs-keyword">return</span> jumpFloor01(target-<span class="hljs-number">1</span>)+jumpFloor01(target-<span class="hljs-number">2</span>);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>优点，代码简单好写，缺点：慢，会超时</p>
<p><strong>时间复杂度</strong>：O(2^n)<br><strong>空间复杂度</strong>：递归栈的空间</p>
<blockquote>
<p>方法二：记忆化搜索（优化递归）</p>
</blockquote>
<p>改进，就用数组把计算过的保存下来。</p>
<p><img src="/2021/06/24/arithmetic/6.1.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//记忆化搜索</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor02</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> num[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">50</span>];<br>        <span class="hljs-keyword">return</span> jumNum(target,num);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target,<span class="hljs-keyword">int</span> num[])</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(num[target]!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> num[target];<br>        <span class="hljs-keyword">return</span> num[target]=jumNum(target-<span class="hljs-number">1</span>,num)+jumNum(target-<span class="hljs-number">2</span>,num);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O（n）， 没有重复的计算<br><strong>空间复杂度</strong>：O（n）和递归栈的空间</p>
<blockquote>
<p>方法三：动态规划</p>
</blockquote>
<p>让空间继续优化，那就用动态规划，优化掉递归栈空间。</p>
<p>方法二是从上往下递归的然后再从下往上回溯的，最后回溯的时候来合并子树从而求得答案。<br>那么动态规划不同的是，不用递归的过程，直接从子树求得答案。过程是从下往上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态规划</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor03</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>       <span class="hljs-keyword">int</span> temp[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">50</span>];<br>       temp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>       temp[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; target; i++) &#123;<br>           temp[i]=temp[i-<span class="hljs-number">1</span>]+temp[i-<span class="hljs-number">2</span>];<br>       &#125;<br>       <span class="hljs-keyword">return</span> temp[target-<span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O(n)<br><strong>空间复杂度</strong>：O(n)</p>
<blockquote>
<p>动态规划进一步优化</p>
</blockquote>
<p>发现计算f[5]的时候只用到了f[4]和f[3], 没有用到f[2]…f[0],所以保存f[2]…f[0]是浪费了空间。<br>只需要用3个变量即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//进一步优化动态规划</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jumpFloor04</span><span class="hljs-params">(<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target==<span class="hljs-number">0</span>||target==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> target+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> a=<span class="hljs-number">1</span>,b=<span class="hljs-number">1</span>,c=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;=target; i++) &#123;<br>            c=a+b;<br>            a=b;<br>            b=c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p><strong>时间复杂度</strong>：O（n）<br><strong>空间复杂度</strong>：O（1）</p>
<h2 id="7、最长无重复子数组"><a href="#7、最长无重复子数组" class="headerlink" title="7、最长无重复子数组"></a>7、最长无重复子数组</h2><p>题目：给定一个数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。</p>
<p>子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</p>
<blockquote>
<p>解法一：双指针</p>
</blockquote>
<blockquote>
<p>解法二：队列</p>
</blockquote>
<blockquote>
<p>解法三：集合</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zhao.elementary;<br><br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/** 最长无重复子数组</span><br><span class="hljs-comment"> * 给定一个数组arr，返回arr的最长无重复元素子数组的长度，</span><br><span class="hljs-comment"> * 无重复指的是所有数字都不相同。</span><br><span class="hljs-comment"> * 子数组是连续的，比如[1,3,5,7,9]的子数组</span><br><span class="hljs-comment"> * 有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组</span><br><span class="hljs-comment"> * [3,3,2,1,3,3,3,1]</span><br><span class="hljs-comment"> * [1,2,3,1,2,3,2,2]</span><br><span class="hljs-comment"> * 使用双指针加map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxLengthArr</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> arr[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;;<br>        System.out.println(maxLength01(arr));<br>        System.out.println(maxLength02(arr));<br>        System.out.println(maxLength03(arr));<br>        System.out.println(maxLength04(arr));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用两个指针，一个i一个j，最开始的时候i和j指向第一个元素，</span><br><span class="hljs-comment">     * 然后i往后移，把扫描过的元素都放到map中，如果i扫描过的元素没有重复的就一直往后移，</span><br><span class="hljs-comment">     * 顺便记录一下最大值max，如果i扫描过的元素有重复的，就改变j的位置，</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength01</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span>(arr.length==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//声明一个map集合用来存放子数组及其下标</span><br>        HashMap&lt;Integer,Integer&gt; map=<span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(arr[i]))&#123;<br>                j=map.get(arr[i])+<span class="hljs-number">1</span>;<br>            &#125;<br>            map.put(arr[i],i);<br>            max= i-j+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用队列完成,把元素不停的加入到队列中，如果有相同的元素，</span><br><span class="hljs-comment">     * 就把队首的元素移除，这样我们就可以保证队列中永远都没有重复的元素</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-comment">//用链表实现队列，队列是先进先出的</span><br>        Queue&lt;Integer&gt; queue=<span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">while</span>(queue.contains(arr[i]))&#123;<br>                <span class="hljs-comment">//如果有重复的，队头出队</span><br>                queue.poll();<br>            &#125;<br>            <span class="hljs-comment">//添加到队尾</span><br>            queue.add(arr[i]);<br>            res = Math.max(res,queue.size());<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用集合set来代替队列，用两个指针，一个left一个right，</span><br><span class="hljs-comment">     * 如果有重复的就把left指向的给移除（left相当于队首，right相当于队尾）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> maxLen = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//声明Set集合</span><br>        Set&lt;Integer&gt; set=<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; arr.length)&#123;<br>            <span class="hljs-keyword">while</span>(set.contains(arr[right]))<br>                <span class="hljs-comment">//right指的数据若与Set集合中的数据重复便移除left所指数据</span><br>                set.remove(arr[left++]);<br>            <span class="hljs-comment">//新的数据添加到right上</span><br>            set.add(arr[right++]);<br>            maxLen = Math.max(maxLen,right - left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>    <span class="hljs-comment">//集合优化</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxLength04</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>,max = <span class="hljs-number">0</span>;<br>        Set&lt;Integer&gt; set =<span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (right &lt; arr.length)&#123;<br>            <span class="hljs-keyword">if</span>(set.contains(arr[right]))&#123;<br>                set.remove(arr[left++]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                set.add(arr[right++]);<br>                max = Math.max(max,set.size());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="8、最小的K个数"><a href="#8、最小的K个数" class="headerlink" title="8、最小的K个数"></a>8、最小的K个数</h2><p>题目：给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。如果K&gt;数组的长度，那么返回一个空的数组</p>
<blockquote>
<p>方法一：排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">GetLeastNumbers_Solution</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        ArrayList&lt;Integer&gt; arrayList=<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(k&gt;input.length) <span class="hljs-keyword">return</span> arrayList;<br>        <span class="hljs-keyword">else</span>&#123;<br>        Arrays.sort(input);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)&#123;<br>            arrayList.add(input[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arrayList;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>方法二：堆排序</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/124885051">【算法】排序算法之堆排序 - 知乎 (zhihu.com)</a></p>
<p>建立一个容量为k的大根堆的优先队列。遍历一遍元素，如果队列大小&lt;k,就直接入队，否则，让当前元素与队顶元素相比，如果队顶元素大，则出队，将当前元素入队</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 堆排序</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;Integer&gt; <span class="hljs-title">GetLeastNumbers02</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] input, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>       ArrayList&lt;Integer&gt; arrayList =<span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>       <span class="hljs-keyword">if</span>(k&gt;input.length) <span class="hljs-keyword">return</span> arrayList;<br>       <span class="hljs-comment">//调用最小堆</span><br>       PriorityQueue&lt;Integer&gt; pq=<span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c:input) &#123;<br>           pq.add(c);<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>           Integer poll = pq.poll();<br>           arrayList.add(poll);<br>       &#125;<br>       <span class="hljs-keyword">return</span> arrayList;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="9、合并两个有序的数组"><a href="#9、合并两个有序的数组" class="headerlink" title="9、合并两个有序的数组"></a>9、合并两个有序的数组</h2><p>题目：给出一个整数数组 A和有序的整数数组 B，请将数组 B合并到数组 A中，变成一个有序的升序数组<br>注意：</p>
<ol>
<li><p>可以假设 A数组有足够的空间存放 B数组的元素， A和B 中初始的元素数目分别为 m和 n，的数组空间大小为 m+n</p>
</li>
<li><p>不要返回合并的数组，返回是空的，将数组 B的数据合并到 A里面就好了</p>
</li>
<li><p>A数组在[0,m-1]的范围也是有序的</p>
</li>
</ol>
<blockquote>
<p>堆排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> B[], <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//声明最小堆</span><br>        PriorityQueue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;<br>            A[m]=B[n-<span class="hljs-number">1</span>];<br>            m++;<br>            n--;<br>        &#125;<br>        <span class="hljs-comment">//入堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m + n; i++) &#123;<br>            pq.add(A[i]);<br>        &#125;<br>        <span class="hljs-comment">//出堆</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m + n; i++) &#123;<br>            Integer poll = pq.poll();<br>            A[i]=poll;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>双指针</p>
</blockquote>
<p>因为A的数组足够大，所以直接拿A数组操作。</p>
<p>合并排序，首先想到双指针，我们开辟指针i，指针j，一个指向A的m-1，一个指向B的n-1，两个指针移动前我们还需要定义一个index=m+n-1代表合并数组的最后一个元素位置。</p>
<p>然后开始移动，A[i]，B[j]比较谁大，就合并谁。</p>
<p>然后最后还得判断一下B合并完成没有，B没有合并完的话，直接把B丢进A。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//双指针合并</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge02</span><span class="hljs-params">(<span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> B[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-comment">//因为题目中明确说了A数组足够大，所以直接在A数组操作</span><br>        <span class="hljs-keyword">int</span> i = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> index = m + n - <span class="hljs-number">1</span>;<span class="hljs-comment">//AB合并后最后元素所在位置</span><br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j&gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//AB合并，谁大就先放谁</span><br>            A[index --] = A[i] &gt; B[j] ? A[i--] :B[j --];<br>        <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//如果B没有遍历完，那么直接全部丢在A数组里面</span><br>            A[index --] = B[j --];<br>    &#125;<br></code></pre></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/JAVA%E5%9F%BA%E7%A1%80/">JAVA基础</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/06/23/faq/">
                        <span class="hidden-mobile">常考Java基础题</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
